using Random
using Plots
using SparseArrays
using Statistics
using Printf
using LinearAlgebra

# "a" est le coefficient qu'on met devant le nouveau V

#_____________________________________________________________________________

function Vd(q)         # définition de la dérivée de la fonction potentiel 
    return sin(q)/2    # potentiel périodique 
end

#_____________________________________________________________________________

function gibbs_RS(a)  # simulation de la mesure de Gibbs par méthode de rejet
#on initialise le while
g = 2*pi*rand() - pi
u = rand()

while u > exp(-a*(1-cos(g))/2) # exp(-(1-cos(q))/2) la valeur de notre densité sans Z
    g = 2*pi*rand() - pi 
    u = rand()
end
return g                     #on termine le programme et renvoie la valeur de la VA ayant pour densité la mesure de Gibbs
end
#_____________________________________________________________________________

function euler_general(q,pas,U)                          # q est la valeur au temps n et "pas" l'incrémentation
    return -pas .* Vd(q) .+ sqrt(2*pas) .* randn() .+ U(q) .* pas    #méthode d'euler
end

#_____________________________________________________________________________

function euler(q,pas)                          # q est la valeur au temps n et "pas" l'incrémentation
    return -pas .* Vd(q) .+ sqrt(2*pas) .* randn()    #méthode d'euler
end
#_____________________________________________________________________________

function green_kubo(N,T,J)        # formule de Green-Kubo, N : découpe de T, T le temps, J nbr pour MC

    pas = T/N                        # construction du pas
    q_0 = [gibbs_RS(1) for i = 1:J]   # itialisation des J trajectoire
    q_T_int = q_0                    
    S = Vd.(q_0).*Vd.(q_0)*pas               # initialisation des J intégrales          
    means, vars = zeros(N), zeros(N)   #initialisation des moyennes et des variances empiriques
    means[1] = mean(S)
    vars[1] = var(S)     

    for n = 2:N
        q_T_int += euler.(q_T_int,pas)   # construction des J trajectoires
        S += Vd.(q_T_int).*Vd.(q_0)*pas              # intégration des J trajectoires
        means[n] = mean(S)
        vars[n] = var(S)
    end
    1 .-means, sqrt.(vars/J)*1.96

end
#_____________________________________________________________________________


function girsanov_general(N,T,J,U)  # N : nbr de pas, T : temps final, J : nombre de réalisation, U nouveau potentiel

    pas = T/N                        # on définit le pas
    q0 = [gibbs_RS(1) for i = 1:J]   # on initialise les J trajectoire
    qT = q0
    S = Vd.(q0).*Vd.(q0)*pas         # début de l'intégration
    means, vars = zeros(N),zeros(N)
    means[1] = mean(S)               # initialisation des moyennes et variances empiriques
    vars[1] = var(S)
    Y = zeros(J)                          

    for n = 2:N                      # calcul des J trajectoires
        qT += euler_general.(qT,pas,U)         # actualisation de la trajectoire
        Y += sqrt(pas)*randn()*U.(qT)/sqrt(2) .+ pas*((U.(qT)).^2)/4  # calcul du log LR
        #qT = qT_new
        S += Vd.(qT).*Vd.(q0)*pas
        means[n] = mean(S.*exp.((-1).*Y))   # mise à jours des moyennes et des variances
        vars[n] = var(S.*exp.((-1).*Y))
    end
    1 .- means, sqrt.(vars/J)*1.96
    end


D = 0.884175564 # valeur obtenue par différences finies
t=10/1000:10/1000:10
U(x) = 0.1 .* Vd(x)

gk,vgk = green_kubo(1000,10,10000)
gkg, vgkg = girsanov_general(1000,10,10000,U)
C = D .+ zeros(1000)

plot(t, gk, ribbon=vgk, label = "Greek-Kubo")
plot!(t, gkg, ribbon=vgkg, label = "Green-Kubo Girsanov")
plot!(t, C, color = "red", label = "Coefficient D")
xlabel!("Temps T")
